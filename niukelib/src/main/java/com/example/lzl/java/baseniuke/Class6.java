package com.example.lzl.java.baseniuke;

/**
 *  HASH函数得出来的是16进制的数
 *  MD5-16个16进制的数组成
 *  经典hash函数的特点：
 *      1）数入是无穷大的
 *      2）输出是有穷尽的（经典hash函数）
 *      3）数入相同，输出结果也相同
 *      4）必然会发生hash碰撞，即输入不同，输出可能相同
 *      5）在整个s域离散分布。（离散性的特点）
 *  可以打乱输入规律通过hash函数
 *  1个hash函数可以生成很多hash函数：将一个hash函数拆分成低8位h1和高八位h2，h3 = h1+1*h2
 *  （hash表就是hashMap）
 *  hash表的经典结构：1.将Key取出来进行hash处理然后跟容量进行%，挂在对应的位置上。增删改查时间复杂度为O(1):离线扩容等方式（不是java中的实现方式）
 *                   2.发生碰撞，链表相连，达到阈值进行扩容
 *  jvmHash表的结构：1.发生碰撞后连接的是红黑树（平衡搜索二叉树）treeMap
 *
 *  hash函数做分流：1.有多少台机器，并进行编号处理
 *            2.分布式读取文件里的数据%机器数量 将数据放在对应的机器的文件里。（将m种字符串均匀的分布在每一台机器上）
 *            3.还太大，可以多线程并发跑任务
 *
 *  等概率返回数入的值：通过两个hash表，当出现删除操作的时候，将最后一个数删除填充删除掉的数。
 *
 *  布隆过滤器（集合）：（爬虫去重问题，黑名单问题）比特类型的map
 *          会存在失误，本来不在黑名单中的数据，当成了在黑名单中
 *          将URL经过k个hash函数后加入到比特数组里
 *          验证时一样的方法
 *          1.需要开多大的空间（单位比特） m = (n*lnp)/(ln2)^2,   bit   n = 样本量  p = 失误率
 *          2.需要多少个hash函数：ln2*m/n  小数向上取整
 *          3.真实的失误率是：（1-e^(-n*k/m)）^k
 *
 *  一致性hash:服务器经典抗压结构，当在要加减服务器的时候会有问题发生，所以引入一致性hash
 *
 *          二分查找：可以查找某个数，也可以查找第一个大于等于或小于等于的某个数。
 *
 *          虚拟节点技术：将服务器处理的hash数据均分，路由表：物理节点对应的虚拟节点，有虚拟节点二分获取数据，交给对应的物理节点存储取
 */
public class Class6 {
    public static void main(String[] args){
        //比特数组
        int[] array = new int[1000];//int 4字节，一字节8 bit,一个int 就是32比特。所以该数组就是32000的比特数组
        int index = 30000;//index的位置设置成1
        //index在那个int数上
        int intIndex = index/32;
        //index在哪个比特上
        int bitIndex = index%32;
        array[intIndex] = (array[intIndex] |(1<<bitIndex));
    }
}
